// This file is generated by lavish: DO NOT EDIT
// https://github.com/fasterthanlime/lavish

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(clippy::all, unknown_lints, unused, non_snake_case)]

pub use schema::*;

pub mod protocol {
    #[derive(Clone, Debug)]
    #[allow(non_camel_case_types, unused)]
    pub enum Params {
        Types_IdentityU8(super::schema::types::identity_u8::Params),
        Types_IdentityU16(super::schema::types::identity_u16::Params),
        Types_IdentityU32(super::schema::types::identity_u32::Params),
        Types_IdentityU64(super::schema::types::identity_u64::Params),
        Types_IdentityI8(super::schema::types::identity_i8::Params),
        Types_IdentityI16(super::schema::types::identity_i16::Params),
        Types_IdentityI32(super::schema::types::identity_i32::Params),
        Types_IdentityI64(super::schema::types::identity_i64::Params),
        Types_IdentityMultiple(super::schema::types::identity_multiple::Params),
        Types_IdentityBool(super::schema::types::identity_bool::Params),
        Types_IdentityString(super::schema::types::identity_string::Params),
        Types_IdentityData(super::schema::types::identity_data::Params),
        Types_IdentityTimestamp(super::schema::types::identity_timestamp::Params),
        Types_IdentityArrayString(super::schema::types::identity_array_string::Params),
        Types_IdentityArrayOptionU32(super::schema::types::identity_array_option_u32::Params),
        Types_IdentityOptionArrayU8(super::schema::types::identity_option_array_u8::Params),
        Types_IdentityMapStringBool(super::schema::types::identity_map_string_bool::Params),
        Types_IdentityStruct(super::schema::types::identity_struct::Params),
        Types_IdentityEnum(super::schema::types::identity_enum::Params),
        Layered_Login_Challenge(super::schema::layered::login::challenge::Params),
        Layered_Login(super::schema::layered::login::Params),
        Lifetime_Shutdown(super::schema::lifetime::shutdown::Params),
    }
    impl ::lavish::Atom<ProtocolMapping> for Params {
        fn method(&self) -> &'static str {
            match self {
                Params::Types_IdentityU8(_) => "types.identity_u8",
                Params::Types_IdentityU16(_) => "types.identity_u16",
                Params::Types_IdentityU32(_) => "types.identity_u32",
                Params::Types_IdentityU64(_) => "types.identity_u64",
                Params::Types_IdentityI8(_) => "types.identity_i8",
                Params::Types_IdentityI16(_) => "types.identity_i16",
                Params::Types_IdentityI32(_) => "types.identity_i32",
                Params::Types_IdentityI64(_) => "types.identity_i64",
                Params::Types_IdentityMultiple(_) => "types.identity_multiple",
                Params::Types_IdentityBool(_) => "types.identity_bool",
                Params::Types_IdentityString(_) => "types.identity_string",
                Params::Types_IdentityData(_) => "types.identity_data",
                Params::Types_IdentityTimestamp(_) => "types.identity_timestamp",
                Params::Types_IdentityArrayString(_) => "types.identity_array_string",
                Params::Types_IdentityArrayOptionU32(_) => "types.identity_array_option_u32",
                Params::Types_IdentityOptionArrayU8(_) => "types.identity_option_array_u8",
                Params::Types_IdentityMapStringBool(_) => "types.identity_map_string_bool",
                Params::Types_IdentityStruct(_) => "types.identity_struct",
                Params::Types_IdentityEnum(_) => "types.identity_enum",
                Params::Layered_Login_Challenge(_) => "layered.login.challenge",
                Params::Layered_Login(_) => "layered.login",
                Params::Lifetime_Shutdown(_) => "lifetime.shutdown",
            }
        }
    }
    impl ::lavish::facts::Factual<super::protocol::ProtocolMapping> for Params {
        fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
        where
            Self: Sized,
            R: ::std::io::Read,
        {
            let len = rd.read_array_len()?;
            if len != 2 {
                unreachable!();
            }
            let typ: u32 = rd.read_int()?;
            match typ {
                0 => Ok(Params::Types_IdentityU8(Self::subread(rd)?)),
                1 => Ok(Params::Types_IdentityU16(Self::subread(rd)?)),
                2 => Ok(Params::Types_IdentityU32(Self::subread(rd)?)),
                3 => Ok(Params::Types_IdentityU64(Self::subread(rd)?)),
                4 => Ok(Params::Types_IdentityI8(Self::subread(rd)?)),
                5 => Ok(Params::Types_IdentityI16(Self::subread(rd)?)),
                6 => Ok(Params::Types_IdentityI32(Self::subread(rd)?)),
                7 => Ok(Params::Types_IdentityI64(Self::subread(rd)?)),
                8 => Ok(Params::Types_IdentityMultiple(Self::subread(rd)?)),
                9 => Ok(Params::Types_IdentityBool(Self::subread(rd)?)),
                10 => Ok(Params::Types_IdentityString(Self::subread(rd)?)),
                11 => Ok(Params::Types_IdentityData(Self::subread(rd)?)),
                12 => Ok(Params::Types_IdentityTimestamp(Self::subread(rd)?)),
                13 => Ok(Params::Types_IdentityArrayString(Self::subread(rd)?)),
                14 => Ok(Params::Types_IdentityArrayOptionU32(Self::subread(rd)?)),
                15 => Ok(Params::Types_IdentityOptionArrayU8(Self::subread(rd)?)),
                16 => Ok(Params::Types_IdentityMapStringBool(Self::subread(rd)?)),
                17 => Ok(Params::Types_IdentityStruct(Self::subread(rd)?)),
                18 => Ok(Params::Types_IdentityEnum(Self::subread(rd)?)),
                19 => Ok(Params::Layered_Login_Challenge(Self::subread(rd)?)),
                20 => Ok(Params::Layered_Login(Self::subread(rd)?)),
                21 => Ok(Params::Lifetime_Shutdown(Self::subread(rd)?)),
                _ => unreachable!(),
            }
        }

        fn write<W>(&self, mapping: &super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
        where
            W: ::std::io::Write,
        {
            let o = &mapping.__Params;
            match self {
                Params::Types_IdentityU8(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityU8", 0, value),
                Params::Types_IdentityU16(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityU16", 1, value),
                Params::Types_IdentityU32(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityU32", 2, value),
                Params::Types_IdentityU64(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityU64", 3, value),
                Params::Types_IdentityI8(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityI8", 4, value),
                Params::Types_IdentityI16(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityI16", 5, value),
                Params::Types_IdentityI32(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityI32", 6, value),
                Params::Types_IdentityI64(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityI64", 7, value),
                Params::Types_IdentityMultiple(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityMultiple", 8, value),
                Params::Types_IdentityBool(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityBool", 9, value),
                Params::Types_IdentityString(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityString", 10, value),
                Params::Types_IdentityData(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityData", 11, value),
                Params::Types_IdentityTimestamp(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityTimestamp", 12, value),
                Params::Types_IdentityArrayString(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityArrayString", 13, value),
                Params::Types_IdentityArrayOptionU32(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityArrayOptionU32", 14, value),
                Params::Types_IdentityOptionArrayU8(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityOptionArrayU8", 15, value),
                Params::Types_IdentityMapStringBool(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityMapStringBool", 16, value),
                Params::Types_IdentityStruct(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityStruct", 17, value),
                Params::Types_IdentityEnum(value) =>
                    o.write_union(wr, mapping, "Params", "Types_IdentityEnum", 18, value),
                Params::Layered_Login_Challenge(value) =>
                    o.write_union(wr, mapping, "Params", "Layered_Login_Challenge", 19, value),
                Params::Layered_Login(value) =>
                    o.write_union(wr, mapping, "Params", "Layered_Login", 20, value),
                Params::Lifetime_Shutdown(value) =>
                    o.write_union(wr, mapping, "Params", "Lifetime_Shutdown", 21, value),
                _ => unreachable!(),
            }
        }
    }

    #[derive(Clone, Debug)]
    #[allow(non_camel_case_types, unused)]
    pub enum Results {
        Types_IdentityU8(super::schema::types::identity_u8::Results),
        Types_IdentityU16(super::schema::types::identity_u16::Results),
        Types_IdentityU32(super::schema::types::identity_u32::Results),
        Types_IdentityU64(super::schema::types::identity_u64::Results),
        Types_IdentityI8(super::schema::types::identity_i8::Results),
        Types_IdentityI16(super::schema::types::identity_i16::Results),
        Types_IdentityI32(super::schema::types::identity_i32::Results),
        Types_IdentityI64(super::schema::types::identity_i64::Results),
        Types_IdentityMultiple(super::schema::types::identity_multiple::Results),
        Types_IdentityBool(super::schema::types::identity_bool::Results),
        Types_IdentityString(super::schema::types::identity_string::Results),
        Types_IdentityData(super::schema::types::identity_data::Results),
        Types_IdentityTimestamp(super::schema::types::identity_timestamp::Results),
        Types_IdentityArrayString(super::schema::types::identity_array_string::Results),
        Types_IdentityArrayOptionU32(super::schema::types::identity_array_option_u32::Results),
        Types_IdentityOptionArrayU8(super::schema::types::identity_option_array_u8::Results),
        Types_IdentityMapStringBool(super::schema::types::identity_map_string_bool::Results),
        Types_IdentityStruct(super::schema::types::identity_struct::Results),
        Types_IdentityEnum(super::schema::types::identity_enum::Results),
        Layered_Login_Challenge(super::schema::layered::login::challenge::Results),
        Layered_Login(super::schema::layered::login::Results),
        Lifetime_Shutdown(super::schema::lifetime::shutdown::Results),
    }
    impl ::lavish::Atom<ProtocolMapping> for Results {
        fn method(&self) -> &'static str {
            match self {
                Results::Types_IdentityU8(_) => "types.identity_u8",
                Results::Types_IdentityU16(_) => "types.identity_u16",
                Results::Types_IdentityU32(_) => "types.identity_u32",
                Results::Types_IdentityU64(_) => "types.identity_u64",
                Results::Types_IdentityI8(_) => "types.identity_i8",
                Results::Types_IdentityI16(_) => "types.identity_i16",
                Results::Types_IdentityI32(_) => "types.identity_i32",
                Results::Types_IdentityI64(_) => "types.identity_i64",
                Results::Types_IdentityMultiple(_) => "types.identity_multiple",
                Results::Types_IdentityBool(_) => "types.identity_bool",
                Results::Types_IdentityString(_) => "types.identity_string",
                Results::Types_IdentityData(_) => "types.identity_data",
                Results::Types_IdentityTimestamp(_) => "types.identity_timestamp",
                Results::Types_IdentityArrayString(_) => "types.identity_array_string",
                Results::Types_IdentityArrayOptionU32(_) => "types.identity_array_option_u32",
                Results::Types_IdentityOptionArrayU8(_) => "types.identity_option_array_u8",
                Results::Types_IdentityMapStringBool(_) => "types.identity_map_string_bool",
                Results::Types_IdentityStruct(_) => "types.identity_struct",
                Results::Types_IdentityEnum(_) => "types.identity_enum",
                Results::Layered_Login_Challenge(_) => "layered.login.challenge",
                Results::Layered_Login(_) => "layered.login",
                Results::Lifetime_Shutdown(_) => "lifetime.shutdown",
            }
        }
    }
    impl ::lavish::facts::Factual<super::protocol::ProtocolMapping> for Results {
        fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
        where
            Self: Sized,
            R: ::std::io::Read,
        {
            let len = rd.read_array_len()?;
            if len != 2 {
                unreachable!();
            }
            let typ: u32 = rd.read_int()?;
            match typ {
                0 => Ok(Results::Types_IdentityU8(Self::subread(rd)?)),
                1 => Ok(Results::Types_IdentityU16(Self::subread(rd)?)),
                2 => Ok(Results::Types_IdentityU32(Self::subread(rd)?)),
                3 => Ok(Results::Types_IdentityU64(Self::subread(rd)?)),
                4 => Ok(Results::Types_IdentityI8(Self::subread(rd)?)),
                5 => Ok(Results::Types_IdentityI16(Self::subread(rd)?)),
                6 => Ok(Results::Types_IdentityI32(Self::subread(rd)?)),
                7 => Ok(Results::Types_IdentityI64(Self::subread(rd)?)),
                8 => Ok(Results::Types_IdentityMultiple(Self::subread(rd)?)),
                9 => Ok(Results::Types_IdentityBool(Self::subread(rd)?)),
                10 => Ok(Results::Types_IdentityString(Self::subread(rd)?)),
                11 => Ok(Results::Types_IdentityData(Self::subread(rd)?)),
                12 => Ok(Results::Types_IdentityTimestamp(Self::subread(rd)?)),
                13 => Ok(Results::Types_IdentityArrayString(Self::subread(rd)?)),
                14 => Ok(Results::Types_IdentityArrayOptionU32(Self::subread(rd)?)),
                15 => Ok(Results::Types_IdentityOptionArrayU8(Self::subread(rd)?)),
                16 => Ok(Results::Types_IdentityMapStringBool(Self::subread(rd)?)),
                17 => Ok(Results::Types_IdentityStruct(Self::subread(rd)?)),
                18 => Ok(Results::Types_IdentityEnum(Self::subread(rd)?)),
                19 => Ok(Results::Layered_Login_Challenge(Self::subread(rd)?)),
                20 => Ok(Results::Layered_Login(Self::subread(rd)?)),
                21 => Ok(Results::Lifetime_Shutdown(Self::subread(rd)?)),
                _ => unreachable!(),
            }
        }

        fn write<W>(&self, mapping: &super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
        where
            W: ::std::io::Write,
        {
            let o = &mapping.__Results;
            match self {
                Results::Types_IdentityU8(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityU8", 0, value),
                Results::Types_IdentityU16(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityU16", 1, value),
                Results::Types_IdentityU32(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityU32", 2, value),
                Results::Types_IdentityU64(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityU64", 3, value),
                Results::Types_IdentityI8(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityI8", 4, value),
                Results::Types_IdentityI16(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityI16", 5, value),
                Results::Types_IdentityI32(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityI32", 6, value),
                Results::Types_IdentityI64(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityI64", 7, value),
                Results::Types_IdentityMultiple(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityMultiple", 8, value),
                Results::Types_IdentityBool(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityBool", 9, value),
                Results::Types_IdentityString(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityString", 10, value),
                Results::Types_IdentityData(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityData", 11, value),
                Results::Types_IdentityTimestamp(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityTimestamp", 12, value),
                Results::Types_IdentityArrayString(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityArrayString", 13, value),
                Results::Types_IdentityArrayOptionU32(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityArrayOptionU32", 14, value),
                Results::Types_IdentityOptionArrayU8(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityOptionArrayU8", 15, value),
                Results::Types_IdentityMapStringBool(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityMapStringBool", 16, value),
                Results::Types_IdentityStruct(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityStruct", 17, value),
                Results::Types_IdentityEnum(value) =>
                    o.write_union(wr, mapping, "Results", "Types_IdentityEnum", 18, value),
                Results::Layered_Login_Challenge(value) =>
                    o.write_union(wr, mapping, "Results", "Layered_Login_Challenge", 19, value),
                Results::Layered_Login(value) =>
                    o.write_union(wr, mapping, "Results", "Layered_Login", 20, value),
                Results::Lifetime_Shutdown(value) =>
                    o.write_union(wr, mapping, "Results", "Lifetime_Shutdown", 21, value),
                _ => unreachable!(),
            }
        }
    }

    #[derive(Clone, Debug)]
    #[allow(non_camel_case_types, unused)]
    pub enum NotificationParams {}
    impl ::lavish::Atom<ProtocolMapping> for NotificationParams {
        fn method(&self) -> &'static str {
            panic!("no variants for NotificationParams")
        }
    }
    impl ::lavish::facts::Factual<super::protocol::ProtocolMapping> for NotificationParams {
        fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
        where
            Self: Sized,
            R: ::std::io::Read,
        {
            let len = rd.read_array_len()?;
            if len != 2 {
                unreachable!();
            }
            let typ: u32 = rd.read_int()?;
            match typ {
                _ => unreachable!(),
            }
        }

        fn write<W>(&self, mapping: &super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
        where
            W: ::std::io::Write,
        {
            let o = &mapping.__NotificationParams;
            match self {
                _ => unreachable!(),
            }
        }
    }

    pub type Caller = ::lavish::Caller<super::protocol::ProtocolMapping, super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;
    pub type Handler<CL> = ::lavish::Handler<CL, super::protocol::ProtocolMapping, super::protocol::Params, super::protocol::NotificationParams, super::protocol::Results>;
    pub trait Callable<R>
    {
        fn upcast_params(self) -> Params;
        fn downcast_results(results: Results) -> Option<R>;
    }

    pub trait Implementable<P>
    {
        fn method() -> &'static str;
        fn downcast_params(params: Params) -> Option<P>;
        fn upcast_results(self) -> Results;
    }

    #[derive(Clone, Copy)]
    pub struct Slottable<P, R>
    where
        R: Implementable<P>,
    {
        pub phantom: std::marker::PhantomData<(P, R)>,
    }

    use ::lavish::facts::{OffsetList, TypeMapping};
    #[derive(Debug)]
    pub struct ProtocolMapping {
        // builtins
        pub __Params: TypeMapping,
        pub __Results: TypeMapping,
        pub __NotificationParams: TypeMapping,
        // structs
        pub Types_Participant: TypeMapping,
        pub Types_IdentityU8_Params: TypeMapping,
        pub Types_IdentityU8_Results: TypeMapping,
        pub Types_IdentityU16_Params: TypeMapping,
        pub Types_IdentityU16_Results: TypeMapping,
        pub Types_IdentityU32_Params: TypeMapping,
        pub Types_IdentityU32_Results: TypeMapping,
        pub Types_IdentityU64_Params: TypeMapping,
        pub Types_IdentityU64_Results: TypeMapping,
        pub Types_IdentityI8_Params: TypeMapping,
        pub Types_IdentityI8_Results: TypeMapping,
        pub Types_IdentityI16_Params: TypeMapping,
        pub Types_IdentityI16_Results: TypeMapping,
        pub Types_IdentityI32_Params: TypeMapping,
        pub Types_IdentityI32_Results: TypeMapping,
        pub Types_IdentityI64_Params: TypeMapping,
        pub Types_IdentityI64_Results: TypeMapping,
        pub Types_IdentityMultiple_Params: TypeMapping,
        pub Types_IdentityMultiple_Results: TypeMapping,
        pub Types_IdentityBool_Params: TypeMapping,
        pub Types_IdentityBool_Results: TypeMapping,
        pub Types_IdentityString_Params: TypeMapping,
        pub Types_IdentityString_Results: TypeMapping,
        pub Types_IdentityData_Params: TypeMapping,
        pub Types_IdentityData_Results: TypeMapping,
        pub Types_IdentityTimestamp_Params: TypeMapping,
        pub Types_IdentityTimestamp_Results: TypeMapping,
        pub Types_IdentityArrayString_Params: TypeMapping,
        pub Types_IdentityArrayString_Results: TypeMapping,
        pub Types_IdentityArrayOptionU32_Params: TypeMapping,
        pub Types_IdentityArrayOptionU32_Results: TypeMapping,
        pub Types_IdentityOptionArrayU8_Params: TypeMapping,
        pub Types_IdentityOptionArrayU8_Results: TypeMapping,
        pub Types_IdentityMapStringBool_Params: TypeMapping,
        pub Types_IdentityMapStringBool_Results: TypeMapping,
        pub Types_IdentityStruct_Params: TypeMapping,
        pub Types_IdentityStruct_Results: TypeMapping,
        pub Types_IdentityEnum_Params: TypeMapping,
        pub Types_IdentityEnum_Results: TypeMapping,
        pub Layered_Login_Params: TypeMapping,
        pub Layered_Login_Results: TypeMapping,
        pub Layered_Login_Challenge_Params: TypeMapping,
        pub Layered_Login_Challenge_Results: TypeMapping,
        pub Lifetime_Shutdown_Params: TypeMapping,
        pub Lifetime_Shutdown_Results: TypeMapping,
        // enums
        pub Types_Mood: TypeMapping,
    }

    impl Default for ProtocolMapping {
        fn default() -> Self {
            Self {
                // builtins
                __Params: TypeMapping::Mapped(OffsetList(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])),
                __Results: TypeMapping::Mapped(OffsetList(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21])),
                __NotificationParams: TypeMapping::Mapped(OffsetList(vec![])),
                // structs
                Types_Participant: TypeMapping::Mapped(OffsetList(vec![0, 1])),
                Types_IdentityU8_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU8_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU16_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU16_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU32_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU32_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU64_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityU64_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI8_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI8_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI16_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI16_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI32_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI32_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI64_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityI64_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityMultiple_Params: TypeMapping::Mapped(OffsetList(vec![0, 1, 2])),
                Types_IdentityMultiple_Results: TypeMapping::Mapped(OffsetList(vec![0, 1, 2])),
                Types_IdentityBool_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityBool_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityString_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityString_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityData_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityData_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityTimestamp_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityTimestamp_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityArrayString_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityArrayString_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityArrayOptionU32_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityArrayOptionU32_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityOptionArrayU8_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityOptionArrayU8_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityMapStringBool_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityMapStringBool_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityStruct_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityStruct_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityEnum_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Types_IdentityEnum_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Layered_Login_Params: TypeMapping::Mapped(OffsetList(vec![])),
                Layered_Login_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Layered_Login_Challenge_Params: TypeMapping::Mapped(OffsetList(vec![0])),
                Layered_Login_Challenge_Results: TypeMapping::Mapped(OffsetList(vec![0])),
                Lifetime_Shutdown_Params: TypeMapping::Mapped(OffsetList(vec![])),
                Lifetime_Shutdown_Results: TypeMapping::Mapped(OffsetList(vec![])),
                // enums
                Types_Mood: TypeMapping::Mapped(OffsetList(vec![0, 1, 2])),
            }
        }
    }
    impl ::lavish::facts::Mapping for ProtocolMapping {}
}

pub mod schema {
    pub mod types {
        #[derive(Clone, Debug)]
        pub struct Participant {
            pub name: String,
            pub age: i16,
        }

        impl ::lavish::facts::Factual<super::super::protocol::ProtocolMapping> for Participant {
            fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
            where
                Self: Sized,
                R: ::std::io::Read,
            {
                rd.expect_array_len(2)?;
                Ok(Self {
                    name: Self::subread(rd)?,
                    age: Self::subread(rd)?,
                })
            }

            fn write<W>(&self, mapping: &super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
            where
                W: ::std::io::Write,
            {
                mapping.Types_Participant.write(wr, |wr, i| match i {
                    0 => self.name.write(mapping, wr),
                    1 => self.age.write(mapping, wr),
                    _ => unreachable!(),
                })
            }
        }
        #[derive(Clone, Copy, Debug)]
        #[repr(u32)]
        pub enum Mood {
            Positive = 0,
            Neutral = 1,
            Negative = 2,
        }

        impl ::lavish::facts::Factual<super::super::protocol::ProtocolMapping> for Mood {
            fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
            where
                Self: Sized,
                R: ::std::io::Read,
            {
                let value: u32 = rd.read_int()?;
                use Mood as E;
                Ok(match value {
                    0 => E::Positive,
                    1 => E::Neutral,
                    2 => E::Negative,
                    _ => return Err(::lavish::facts::Error::IncompatibleSchema(format!("Received unrecognized enum variant for Mood: {:#?}", value))),
                })
            }

            fn write<W>(&self, mapping: &super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
            where
                Self: Sized,
                W: ::std::io::Write,
            {
                let offsets = mapping.Types_Mood.validate()?;
                match offsets.get(*self as usize)
                {
                    Some(value) => value.write(mapping, wr),
                    None => Err(::lavish::facts::Error::IncompatibleSchema(format!("Enum variant for Mood not known by the peer: {:#?}", self))),
                }
            }
        }
        pub use identity_u8::method as identity_u8;
        pub mod identity_u8 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: u8,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU8_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: u8,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU8_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityU8(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityU8(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_u8"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityU8(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityU8(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_u16::method as identity_u16;
        pub mod identity_u16 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: u16,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU16_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: u16,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU16_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityU16(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityU16(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_u16"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityU16(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityU16(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_u32::method as identity_u32;
        pub mod identity_u32 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: u32,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU32_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: u32,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU32_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityU32(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityU32(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_u32"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityU32(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityU32(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_u64::method as identity_u64;
        pub mod identity_u64 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: u64,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU64_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: u64,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityU64_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityU64(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityU64(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_u64"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityU64(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityU64(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_i8::method as identity_i8;
        pub mod identity_i8 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: i8,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI8_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: i8,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI8_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityI8(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityI8(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_i8"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityI8(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityI8(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_i16::method as identity_i16;
        pub mod identity_i16 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: i16,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI16_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: i16,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI16_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityI16(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityI16(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_i16"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityI16(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityI16(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_i32::method as identity_i32;
        pub mod identity_i32 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: i32,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI32_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: i32,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI32_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityI32(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityI32(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_i32"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityI32(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityI32(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_i64::method as identity_i64;
        pub mod identity_i64 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: i64,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI64_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: i64,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityI64_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityI64(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityI64(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_i64"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityI64(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityI64(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_multiple::method as identity_multiple;
        pub mod identity_multiple {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: i32,
                pub y: String,
                pub z: bool,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(3)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                        y: Self::subread(rd)?,
                        z: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityMultiple_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        1 => self.y.write(mapping, wr),
                        2 => self.z.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: i32,
                pub y: String,
                pub z: bool,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(3)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                        y: Self::subread(rd)?,
                        z: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityMultiple_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        1 => self.y.write(mapping, wr),
                        2 => self.z.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityMultiple(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityMultiple(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_multiple"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityMultiple(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityMultiple(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_bool::method as identity_bool;
        pub mod identity_bool {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: bool,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityBool_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: bool,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityBool_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityBool(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityBool(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_bool"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityBool(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityBool(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_string::method as identity_string;
        pub mod identity_string {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: String,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityString_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: String,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityString_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityString(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityString(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_string"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityString(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityString(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_data::method as identity_data;
        pub mod identity_data {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: ::lavish::facts::Bin,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityData_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: ::lavish::facts::Bin,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityData_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityData(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityData(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_data"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityData(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityData(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_timestamp::method as identity_timestamp;
        pub mod identity_timestamp {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: ::lavish::chrono::DateTime<::lavish::chrono::offset::Utc>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityTimestamp_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: ::lavish::chrono::DateTime<::lavish::chrono::offset::Utc>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityTimestamp_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityTimestamp(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityTimestamp(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_timestamp"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityTimestamp(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityTimestamp(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_array_string::method as identity_array_string;
        pub mod identity_array_string {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: Vec<String>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityArrayString_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: Vec<String>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityArrayString_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityArrayString(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityArrayString(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_array_string"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityArrayString(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityArrayString(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_array_option_u32::method as identity_array_option_u32;
        pub mod identity_array_option_u32 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: Vec<Option<u32>>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityArrayOptionU32_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: Vec<Option<u32>>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityArrayOptionU32_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityArrayOptionU32(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityArrayOptionU32(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_array_option_u32"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityArrayOptionU32(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityArrayOptionU32(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_option_array_u8::method as identity_option_array_u8;
        pub mod identity_option_array_u8 {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: Option<Vec<u8>>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityOptionArrayU8_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: Option<Vec<u8>>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityOptionArrayU8_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityOptionArrayU8(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityOptionArrayU8(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_option_array_u8"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityOptionArrayU8(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityOptionArrayU8(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_map_string_bool::method as identity_map_string_bool;
        pub mod identity_map_string_bool {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: ::std::collections::HashMap<String, bool>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityMapStringBool_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: ::std::collections::HashMap<String, bool>,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityMapStringBool_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityMapStringBool(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityMapStringBool(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_map_string_bool"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityMapStringBool(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityMapStringBool(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_struct::method as identity_struct;
        pub mod identity_struct {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: super::Participant,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityStruct_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: super::Participant,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityStruct_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityStruct(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityStruct(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_struct"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityStruct(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityStruct(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
        pub use identity_enum::method as identity_enum;
        pub mod identity_enum {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
                pub x: super::Mood,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityEnum_Params.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub x: super::Mood,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        x: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Types_IdentityEnum_Results.write(wr, |wr, i| match i {
                        0 => self.x.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Types_IdentityEnum(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Types_IdentityEnum(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "types.identity_enum"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Types_IdentityEnum(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Types_IdentityEnum(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
    }
    pub mod layered {
        pub use login::method as login;
        pub mod login {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(0)?;
                    Ok(Self {
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Layered_Login_Params.write(wr, |wr, i| match i {
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
                pub ok: bool,
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(1)?;
                    Ok(Self {
                        ok: Self::subread(rd)?,
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Layered_Login_Results.write(wr, |wr, i| match i {
                        0 => self.ok.write(mapping, wr),
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Layered_Login(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Layered_Login(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "layered.login"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Layered_Login(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Layered_Login(p) => Some(p),
                        _ => None,
                    }
                }
            }

            pub use challenge::method as challenge;
            pub mod challenge {
                pub fn method() -> super::super::super::super::protocol::Slottable<Params, Results> {
                    super::super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
                }
                #[derive(Clone, Debug)]
                pub struct Params {
                    pub input: String,
                }

                impl ::lavish::facts::Factual<super::super::super::super::protocol::ProtocolMapping> for Params {
                    fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                    where
                        Self: Sized,
                        R: ::std::io::Read,
                    {
                        rd.expect_array_len(1)?;
                        Ok(Self {
                            input: Self::subread(rd)?,
                        })
                    }

                    fn write<W>(&self, mapping: &super::super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                    where
                        W: ::std::io::Write,
                    {
                        mapping.Layered_Login_Challenge_Params.write(wr, |wr, i| match i {
                            0 => self.input.write(mapping, wr),
                            _ => unreachable!(),
                        })
                    }
                }
                #[derive(Clone, Debug)]
                pub struct Results {
                    pub hashed: String,
                }

                impl ::lavish::facts::Factual<super::super::super::super::protocol::ProtocolMapping> for Results {
                    fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                    where
                        Self: Sized,
                        R: ::std::io::Read,
                    {
                        rd.expect_array_len(1)?;
                        Ok(Self {
                            hashed: Self::subread(rd)?,
                        })
                    }

                    fn write<W>(&self, mapping: &super::super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                    where
                        W: ::std::io::Write,
                    {
                        mapping.Layered_Login_Challenge_Results.write(wr, |wr, i| match i {
                            0 => self.hashed.write(mapping, wr),
                            _ => unreachable!(),
                        })
                    }
                }

                impl super::super::super::super::protocol::Callable<Results> for Params {
                    fn upcast_params(self) -> super::super::super::super::protocol::Params {
                        super::super::super::super::protocol::Params::Layered_Login_Challenge(self)
                    }
                    fn downcast_results(results: super::super::super::super::protocol::Results) -> Option<Results> {
                        match results {
                            super::super::super::super::protocol::Results::Layered_Login_Challenge(r) => Some(r),
                            _ => None,
                        }
                    }
                }

                impl super::super::super::super::protocol::Implementable<Params> for Results {
                    fn method() -> &'static str {
                        "layered.login.challenge"
                    }
                    fn upcast_results(self) -> super::super::super::super::protocol::Results {
                        super::super::super::super::protocol::Results::Layered_Login_Challenge(self)
                    }
                    fn downcast_params(params: super::super::super::super::protocol::Params) -> Option<Params> {
                        match params {
                            super::super::super::super::protocol::Params::Layered_Login_Challenge(p) => Some(p),
                            _ => None,
                        }
                    }
                }
            }
        }
    }
    pub mod lifetime {
        pub use shutdown::method as shutdown;
        pub mod shutdown {
            pub fn method() -> super::super::super::protocol::Slottable<Params, Results> {
                super::super::super::protocol::Slottable { phantom: std::marker::PhantomData }
            }
            #[derive(Clone, Debug)]
            pub struct Params {
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Params {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(0)?;
                    Ok(Self {
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Lifetime_Shutdown_Params.write(wr, |wr, i| match i {
                        _ => unreachable!(),
                    })
                }
            }
            #[derive(Clone, Debug)]
            pub struct Results {
            }

            impl ::lavish::facts::Factual<super::super::super::protocol::ProtocolMapping> for Results {
                fn read<R>(rd: &mut ::lavish::facts::Reader<R>) -> Result<Self, ::lavish::facts::Error>
                where
                    Self: Sized,
                    R: ::std::io::Read,
                {
                    rd.expect_array_len(0)?;
                    Ok(Self {
                    })
                }

                fn write<W>(&self, mapping: &super::super::super::protocol::ProtocolMapping, wr: &mut W) -> Result<(), ::lavish::facts::Error>
                where
                    W: ::std::io::Write,
                {
                    mapping.Lifetime_Shutdown_Results.write(wr, |wr, i| match i {
                        _ => unreachable!(),
                    })
                }
            }

            impl super::super::super::protocol::Callable<Results> for Params {
                fn upcast_params(self) -> super::super::super::protocol::Params {
                    super::super::super::protocol::Params::Lifetime_Shutdown(self)
                }
                fn downcast_results(results: super::super::super::protocol::Results) -> Option<Results> {
                    match results {
                        super::super::super::protocol::Results::Lifetime_Shutdown(r) => Some(r),
                        _ => None,
                    }
                }
            }

            impl super::super::super::protocol::Implementable<Params> for Results {
                fn method() -> &'static str {
                    "lifetime.shutdown"
                }
                fn upcast_results(self) -> super::super::super::protocol::Results {
                    super::super::super::protocol::Results::Lifetime_Shutdown(self)
                }
                fn downcast_params(params: super::super::super::protocol::Params) -> Option<Params> {
                    match params {
                        super::super::super::protocol::Params::Lifetime_Shutdown(p) => Some(p),
                        _ => None,
                    }
                }
            }
        }
    }
    pub mod client {
        #[derive(Clone)]
        pub struct Client {
            caller: super::super::protocol::Caller,
        }

        impl Client {
            pub fn new(caller: super::super::protocol::Caller) -> Self {
                Self { caller }
            }
            pub fn call<P, R>(&self, p: P) -> Result<R, ::lavish::Error>
            where
                P: super::super::protocol::Callable<R>,
            {
                self.caller.call(
                    p.upcast_params(),
                    P::downcast_results,
                )
            }
        }
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::client::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
            pub fn shutdown_runtime(&self) {
                self.client.caller.shutdown_runtime();
            }
        }
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub struct Router<T>
        where
            T: Send + Sync + 'static
        {
            state: std::sync::Arc<T>,
            slots: ::std::collections::HashMap<&'static str, Box<SlotFn<T>>>,
        }

        impl<T> Router<T>
        where
            T: Send + Sync + 'static,
        {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    slots: ::std::collections::HashMap::new(),
                }
            }
            pub fn handle<S, P, R, F>(&mut self, s: S, f: F)
            where
                S: Fn() -> super::super::protocol::Slottable<P, R>,
                R: super::super::protocol::Implementable<P>,
                F: Fn(Call<T, P>) -> Result<R, ::lavish::Error> + 'static + Send + Sync,
            {
                self.slots.insert(R::method(), Box::new(move |call| {
                    let call = call.downcast(R::downcast_params)?;
                    f(call).map(|r| r.upcast_results())
                }));
            }
        }
        impl<T> ::lavish::Handler<Client, super::super::protocol::ProtocolMapping, super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Router<T>
        where
            T: Send + Sync + 'static,
        {
            fn handle(&self, caller: super::super::protocol::Caller, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                let slot = self.slots.get(params.method())
                    .ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::client::Client { caller },
                    params,
                };
                slot(call)
            }
            fn make_client(caller: super::super::protocol::Caller) -> Client {
                Client { caller }
            }
        }
    }

    pub mod server {
        #[derive(Clone)]
        pub struct Client {
            caller: super::super::protocol::Caller,
        }

        impl Client {
            pub fn new(caller: super::super::protocol::Caller) -> Self {
                Self { caller }
            }
            pub fn call<P, R>(&self, p: P) -> Result<R, ::lavish::Error>
            where
                P: super::super::protocol::Callable<R>,
            {
                self.caller.call(
                    p.upcast_params(),
                    P::downcast_results,
                )
            }
        }
        pub struct Call<T, P> {
            pub state: ::std::sync::Arc<T>,
            pub client: super::server::Client,
            pub params: P,
        }

        impl<T, P> Call<T, P> {
            fn downcast<PP, F>(self, f: F) -> Result<Call<T, PP>, ::lavish::Error>
            where
                F: Fn(P) -> Option<PP>,
            {
                Ok(Call {
                    state: self.state,
                    client: self.client,
                    params: f(self.params).ok_or_else(|| ::lavish::Error::WrongParams)?,
                })
            }
            pub fn shutdown_runtime(&self) {
                self.client.caller.shutdown_runtime();
            }
        }
        pub type SlotReturn = Result<super::super::protocol::Results, ::lavish::Error>;
        pub type SlotFn<T> = Fn(Call<T, super::super::protocol::Params>) -> SlotReturn + 'static + Send + Sync;
        pub struct Router<T>
        where
            T: Send + Sync + 'static
        {
            state: std::sync::Arc<T>,
            slots: ::std::collections::HashMap<&'static str, Box<SlotFn<T>>>,
        }

        impl<T> Router<T>
        where
            T: Send + Sync + 'static,
        {
            pub fn new(state: ::std::sync::Arc<T>) -> Self {
                Self {
                    state,
                    slots: ::std::collections::HashMap::new(),
                }
            }
            pub fn handle<S, P, R, F>(&mut self, s: S, f: F)
            where
                S: Fn() -> super::super::protocol::Slottable<P, R>,
                R: super::super::protocol::Implementable<P>,
                F: Fn(Call<T, P>) -> Result<R, ::lavish::Error> + 'static + Send + Sync,
            {
                self.slots.insert(R::method(), Box::new(move |call| {
                    let call = call.downcast(R::downcast_params)?;
                    f(call).map(|r| r.upcast_results())
                }));
            }
        }
        impl<T> ::lavish::Handler<Client, super::super::protocol::ProtocolMapping, super::super::protocol::Params, super::super::protocol::NotificationParams, super::super::protocol::Results> for Router<T>
        where
            T: Send + Sync + 'static,
        {
            fn handle(&self, caller: super::super::protocol::Caller, params: super::super::protocol::Params) -> Result<super::super::protocol::Results, ::lavish::Error> {
                use ::lavish::Atom;
                let slot = self.slots.get(params.method())
                    .ok_or_else(|| ::lavish::Error::MethodUnimplemented(params.method()))?;
                let call = Call {
                    state: self.state.clone(),
                    client: super::server::Client { caller },
                    params,
                };
                slot(call)
            }
            fn make_client(caller: super::super::protocol::Caller) -> Client {
                Client { caller }
            }
        }
    }

}

